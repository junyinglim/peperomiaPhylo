fossilTime ~ dnUniform(66.0, 68.0)
fossilTime.setValue(67.0)
originTime_sd ~ dnUniform(1E-5, 1)
originTime_sd.setValue(0.5)
originTime ~ dnLognormal(mean = fossilTime, sd = originTime_sd)
moves[++mvi] = mvScale( fossilTime, tune = true, weight = 1, lambda = 1.0)
moves[++mvi] = mvScale( originTime, tune = true, weight = 3, lambda = 1.0)
## DEFINE TREEMODEL ==============
for(i in 1:n_branches){
AbstractHomologousDiscreteCharacterDatarandomBL[i] <- dnExponential(1)
}
n_branches
tau
### PEPEROMIA DIVERGENCE TIME ANALYSIS
# IMPORT DATA ==============
stem = "/output/bayes_clock"
data = readDiscreteCharacterData("/Users/junyinglim/Dropbox/Projects/2015/Peperomia/data/concatAlign_clock_160618.phy")
n_species <- data.ntaxa()n_branches <- 2 * n_species - 2 # 2N - 3 (only true for unrooted), 2N-2 for rootedtaxa <- data.taxa()mvi = 0mni = 0## DEFINE SUBSTITUTION MODEL ==============# Exchangeability rateser_prior <- v(1,1,1,1,1,1)er ~ dnDirichlet(er_prior)moves[++mvi] = mvSimplexElementScale(er, alpha=10, tune=true, weight=3) # Stationary frequenciespi_prior <- v(1,1,1,1)pi ~ dnDirichlet(pi_prior)moves[++mvi] = mvSimplexElementScale(pi, alpha = 10, tune=true, weight=2)Q := fnGTR(er, pi)# Gamma parameteralpha_prior_mean <- ln(2.0)alpha_prior_sd <- 0.587405alpha ~ dnLognormal(alpha_prior_mean, alpha_prior_sd)gamma_rates := fnDiscretizeGamma(alpha, alpha, 4, false)moves[++mvi] = mvScale(alpha, tune = true, weight = 2)# # Invariant sites# pinvar ~ dnBeta(1,1)# moves[++mvi] = mvScale(pinvar, lambda=0.1, tune=false, weight=2.0)# moves[++mvi] = mvSlide(pinvar, delta=10.0, tune=false, weight=2.0)## CLOCK MODEL ==============# Branch length priornum_rate_categories = 10ucln_mean ~ dnUniform(1E-5, 1)
ucln_sd ~ dnExponential(1.0)
rate_categories := fnDiscretizeDistribution( dnLognormal(ucln_mean, ucln_sd), num_rate_categories)
rate_probs <- simplex(rep(1, num_rate_categories))
moves[++mvi] = mvScale(ucln_mean, lambda = 1, weight = 5, tune = true)
moves[++mvi] = mvScale(ucln_sd, lambda = 1, weight = 5, tune = true)
for(j in 1:n_branches){
AbstractHomologousDiscreteCharacterDatabranch_rates[j] ~ dnMixture(rate_categories, rate_probs)
AbstractHomologousDiscreteCharacterDatamoves[++mvi] = mvMixtureAllocation( branch_rates[j], weight = 3.0)
}
# Every branch has equal probability to be in any of the 10 rate categories, but because it is discretized, most of the rate categories will be close to the mean
## ORIGIN TIMES ==============
fossilTime ~ dnUniform(66.0, 68.0)
fossilTime.setValue(67.0)
originTime_sd ~ dnUniform(1E-5, 1)
originTime_sd.setValue(0.5)
originTime ~ dnLognormal(mean = fossilTime, sd = originTime_sd)
moves[++mvi] = mvScale( fossilTime, tune = true, weight = 1, lambda = 1.0)
moves[++mvi] = mvScale( originTime, tune = true, weight = 3, lambda = 1.0)
## DEFINE TREEMODEL ==============
# Diversification
# diversification ~ dnLognormal(mean = ln(n_species) / originTime, sd = 0.587405)
# turnover ~ dnUniform(1E-6, 0.99999)
# lambda := diversification / abs(1.0 - turnover)
# mu := turnover * lambda
# Following Condamine et al (2015) BMC Evol Biol
lambda ~ dnUniform(1E-6, 10.0)
lambda.setValue(0.1)
turnover ~ dnUniform(1E-6, 1.0) # relative to birth rate
turnover.setValue(0.5)
mu := turnover * lambda
# Birth-death tree 
tau ~ dnBirthDeath( lambda = lambda,
Boolmu = mu,
Boolrho = 1.0,
BoolrootAge = abs(originTime),
BoolsamplingStrategy="uniform",
Boolcondition = "time",
Booltaxa = data.names()
AbstractHomologousDiscreteCharacterData[][][]  )
tau
data.names()
lambda
mu
tau ~ dnBirthDeath( lambda = lambda,
Boolmu = mu,
Boolrho = 1.0,
BoolrootAge = abs(originTime),
BoolsamplingStrategy="uniform",
Boolcondition = "time",
Booltaxa = data.names()
AbstractHomologousDiscreteCharacterData[][][]  )
originTime
fossilTime
originTime_sd
originTime
dnExponential
1/3
data
62/3431
dnLognormal
dnSoftBoundUniformNormal
dnLognormal
dnLognormal(1, 0.5, 1)
x ~ dnLognormal(1, 0.5, 1)
x
x ~ dnLognormal(1, 0.5, 0)
x
mymcmc.run(50000)
dnLognormal
x = "test"
x in ["test", "test2"]
x in v["test", "test2"]
x %in% ["test", "test2"]
in
x == test[1]
y= ["test", "test2"]
x in y
x intersect y
intersect
x == "test" | x == "test2"
x == "test3" | x == "test2"
x == "test3" | x == "test"
