### PEPEROMIA DIVERGENCE TIME ANALYSIS

# IMPORT DATA ==============
stem = "bayes_clock_rho_complete"
data = readDiscreteCharacterData("/Users/junyinglim/Dropbox/Projects/2015/Peperomia/data/concatAlign_clock_160618.phy")

n_species <- data.ntaxa()
n_branches <- 2 * n_species - 2 # 2N - 3 (only true for unrooted), 2N-2 for rooted
taxa <- data.taxa()

mvi = 0
mni = 0

## DEFINE SUBSTITUTION MODEL ==============
# Exchangeability rates
er_prior <- v(1,1,1,1,1,1)
er ~ dnDirichlet(er_prior)
moves[++mvi] = mvSimplexElementScale(er, alpha=10, tune=true, weight=3) 

# Stationary frequencies
pi_prior <- v(1,1,1,1)
pi ~ dnDirichlet(pi_prior)
moves[++mvi] = mvSimplexElementScale(pi, alpha = 10, tune=true, weight=2)

Q := fnGTR(er, pi)

# Gamma parameter
alpha_prior_mean <- ln(2.0)
alpha_prior_sd <- 0.587405
alpha ~ dnLognormal(alpha_prior_mean, alpha_prior_sd)
gamma_rates := fnDiscretizeGamma(alpha, alpha, 4, false)
moves[++mvi] = mvScale(alpha, tune = true, weight = 2)

## CLOCK MODEL ==============
# Branch length prior
num_rate_categories = 10
ucln_mean ~ dnUniform(1E-5, 1)
ucln_sd ~ dnExponential(1/3) # following Condamine
rate_categories := fnDiscretizeDistribution( dnLognormal(ucln_mean, ucln_sd), num_rate_categories)
rate_probs <- simplex(rep(1, num_rate_categories))
moves[++mvi] = mvScale(ucln_mean, weight = 5, tune = true)
moves[++mvi] = mvScale(ucln_sd, weight = 5, tune = true, lambda = 3.0)

for(j in 1:n_branches){
	branch_rates[j] ~ dnMixture(rate_categories, rate_probs)
	moves[++mvi] = mvMixtureAllocation( branch_rates[j], weight = 10.0)
}
# Every branch has equal probability to be in any of the 10 rate categories, but because it is discretized, most of the rate categories will be close to the mean

## ORIGIN TIMES ==============
fossilTime ~ dnUniform(66.0, 68.0) # hyper prior on fossil stratigraphic range
fossilTime.setValue(67.0)

# originTime_sd ~ dnExponential(0.5)
# originTime_sd ~ dnUniform(1E-5, 1)
originTime_sd ~ dnExponential(0.5)
originTime_sd.setValue(0.5)

originTime ~ dnLognormal(mean = ln(fossilTime), sd = originTime_sd) # lognormal favors somewhat older dates
originTime.setValue(67.0)
moves[++mvi] = mvScale( fossilTime, tune = true, weight = 1)
moves[++mvi] = mvScale( originTime_sd, tune = true, weight = 2)
moves[++mvi] = mvScale( originTime, tune = true, weight = 3)

## DEFINE TREEMODEL ==============
# Diversification
# diversification ~ dnLognormal(mean = ln(n_species) / originTime, sd = 0.587405)
# turnover ~ dnUniform(1E-6, 0.99999)
# lambda := diversification / abs(1.0 - turnover)
# mu := turnover * lambda

# Following Condamine et al (2015) BMC Evol Biol
lambda ~ dnUniform(1E-6, 10.0)
lambda.setValue(0.1)

turnover ~ dnUniform(1E-6, 1.0) # relative to birth rate
turnover.setValue(0.5)
mu := turnover * lambda

moves[++mvi] = mvScale(lambda, weight = 3.0, tune = true)
moves[++mvi] = mvScale(turnover, weight = 3.0, tune = true)

# Birth-death tree 
tau ~ dnBirthDeath( lambda = lambda,
					mu = mu,
					rho = 1.0,
					rootAge = abs(fossilTime),
					samplingStrategy="diversified",
					condition = "time",
					taxa = data.names()
				  )
# According to Kew, 1339 accepted Peperomia and 2092 accepted Piper species
# 

# Define tree moves
moves[++mvi] = mvNarrow(tau, weight=5.0)
moves[++mvi] = mvNNI(tau, weight=1.0)
moves[++mvi] = mvFNPR(tau, weight=5.0)
moves[++mvi] = mvSubtreeScale(tau, weight=3.0)
moves[++mvi] = mvNodeTimeSlideUniform(tau, weight=15.0)


## GENERATE MODEL ==============
print("Initialize model ...")
phyloSeq ~ dnPhyloCTMC(tree=tau,
					   Q=Q,
					   siteRates = gamma_rates,
					   branchRates = branch_rates,
					   type="DNA"
					   )
phyloSeq.clamp(data)
mymodel = model(phyloSeq)

# add monitors
monitors[++mni] = mnModel(filename=stem+".log",printgen=10)
monitors[++mni] = mnFile(tau, filename=stem+".trees", printgen=10)
monitors[++mni] = mnScreen(originTime, printgen=10)

# run the analysis
mymcmc = mcmc(mymodel, moves, monitors)
#), nchains = 4) # perhaps try out a mcmcmc with multiple chains?
mymcmc.burnin(10000, tuningInterval = 200)
mymcmc.run(50000)

# summarize output
# treetrace = readTreeTrace(stem+"_gene.trees", treetype="clock")
# map_tree = mapTree(treetrace, stem+"_gene_map.tre")

# q()